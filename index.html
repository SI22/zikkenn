<!DOCTYPE html>
<html>
  <head>
    <title>数学用語辞書</title>
    <script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    <style>
      .term {
        cursor: pointer;
      }
      
      .definition {
        display: none;
      }
      
      .show {
        display: block;
      }
    </style>
  </head>
  <body>
    <h1>数学用語辞書</h1>
    <h2>   用語をクリックすると説明が表示される</h2>
    <div id="dictionary"></div>
    <form action ="https://si22.github.io/zikkenn/" method="get">
      <input type ="search" name="serch" placeholder="実験です何か検索のキーワードを入力してみてください">
      <input type="submit" name="submit" value=""検索">
                                                    </form>
      <details open> 
      <summary>クリックして詳細をチェック</summary>
        <li>情報1</li>
        <li>情報2</li>
        <li>情報3</li>
    </details>
        
    <script>
      var terms = {
        // ... add more terms here
 "内積":"2つのベクトルの積を表し、スカラー値を返す",
         "ノルム":"ベクトルの大きさを表す",
"三角不等式":"任意の3つのベクトルa, b, cについて、a + b ≥ |a + b|, |a - b| ≤ |a| + |b|が成り立つ",
"Schwarz不等式":"任意の2つのベクトルa, bについて、|a・b| ≤ |a|・|b|が成り立つ",
"N次元ユークリッド空間":"N個の要素からなるベクトルを要素とする空間",
"点列":"数列の一種で、数学的な関数によって生成される点の並びを表す",
"収束":"点列がある値に近づいて収束すること",
"極限":"収束した値を指す",
"収束列":"収束する点列",
"有界":"上限と下限が存在すること",
"Bolzano-Weiwestrassの定理":"有界な点列が存在するとき、その点列には収束する点が存在する",
"Cauchy列完備性":"Cauchy列は収束する点列に収束する",
"補集合":"ある集合に含まれない要素の集合",
"ε-近傍":"点からε以内の距離にある点の集合",
"開集合":"端点を含まない区間を表す",
"閉集合":"端点を含む区間を表す",
"弧状連結":"2点間を曲線で結ぶこと",
"領域":"平面上の点の集合",
"収束":"点列がある値に近づいて収束すること",
"極限値":" 関数が独立変数が特定の値に近づくにつれて取る値",
"連続":" 値が急激に変化しない関数",
"最大値・最小値の定理":" 閉じられた限られた区間で一次微分が連続な関数はその区間上で最大値・最小値を取る",
"一様連続":" 閉じられた限られた区間で連続であり、区間の長さに関わらず、関数値の差が特定の値ε以下である関数",
"合成関数の連続性":" 2つの連続関数からなる関数は連続である",
"偏微分可能":" その領域内のそれぞれの点で偏微分が存在する関数",
"偏微分係数":" 1つの変数に対する関数の変化率",
"偏導関数":" 偏微分係数を与える関数",
"全微分可能":" その領域内のそれぞれの点で偏微分が存在し、連続である関数",
"勾配":" 偏微分係数のベクトル",
"グラディエント":" 偏微分係数のベクトル",
"C^1級":" 1次導関数が存在し、連続な関数",
"多重指数":" 変数の指数が変数の多重指数を取る数学式",
"多重指数の長さ":" 多重指数の項の数",
"C^n級":" n次導関数が存在し、連続な関数",
"Jacobi行列":" ベクトル値関数の偏導関数の行列",
"Jacobian":" Jacobi行列の行列式",
"連鎖律":"多変数関数において、微分の結合則。合成関数の微分は、各関数の微分の積によって計算できる",
"微分作用素":"微分方程式において、微分係数を表す記号",
"Laplace作用素":"二次形式に対する微分作用素",
"調和関数":"微分方程式において、偏微分方程式の形式がLaplace作用素の形式になっている関数",
"Taylorの定理":"関数を特定の点で展開した結果をTaylor展開という",
"Maclaurinの定理":"特殊なTaylor展開、原点でのTaylor展開",
"平均値の定理":"二次形式の指数部分が一定である場合、二次形式の最大値と最小値の平均値がその値",
"極大":"関数が持つ最大値",
"極小":"関数が持つ最小値",
"極値":"極大値、極小値",
"停留点":"関数が持つ局所的な最大値、最小値の点",
"二次形式":"変数が二つの多項式",
"正定値":"二次形式が正の値を持つ",
"負定値":"二次形式が負の値を持つ",
"不定符号":"二次形式が正負の値を持つ",
"Hesse行列":"二次形式の次数が二の関数の微分係数の組",
"Hessian":"Hesse行列",
"陰関数 (Implicit function)":" 関数のyがf(x,y)で表されるような形で表される関数。具体的には、y=g(x)と表されるようなgを求めるために使用されます",
"陰関数定理 (Implicit function theorem)":" 関数 f(x,y)がx,yに関して十分に近似的である場合、yがxに対して単調的である場合、y=g(x)という陰関数が存在し、gはxに関して近似的に計算できます",
"逆関数 (Inverse function)":" 関数f(x)が単射である場合、それに対応する逆関数f^-1(x)が存在します。f^-1(x)はf(x)のxに対する逆関数であり、x=f^-1(y)はy=f(x)と同値です",
"逆関数定理 (Inverse function theorem)":" 関数 f(x)がxに関して十分に近似的であり、かつその導関数がxに対して十分に大きい場合、f(x)はxに対する逆関数を持ち、それは近似的に計算できます",
"Lagrangeの未定乗数法 (Lagrange's undetermined multipliers)":" 多変数関数の最小値、最大値を求める問題に対して、関数と制約条件を合成した新しい関数を最小化することで解を求める方法",
"直積 (Direct product)":" 2つの集合A,Bの直積は、A×B={(a,b)|a∈A,b∈B}と定義される集合です",
"立方体 (Cube)":" 3次元空間上の立方体は、6面からなる四角形の体積です",
"体積":"物体の集合からなる空間の領域の大きさを表す数値です。立体や立方体などの形状に対して、体積は形状の領域に対応する数値です",
"分割":"体積を一定の大きさに分けることを指します。例えば、立方体を小さな立方体に分割することで、立方体の体積を細かく計算することができます",
"過剰和":"体積を分割した際、分割した体積の大きさを足し合わせた数値が元の体積よりも大きくなっていることを指します。これは分割した体積が元の体積を覆っているために起こります",
"不足和":"体積を分割した際、分割した体積の大きさを足し合わせた数値が元の体積よりも小さくなっていることを指します。これは分割した体積が元の体積を完全に覆っていないために起こります",
"上積分、下積分":"体積を分割した際、分割した体積の大きさを足し合わせた数値が元の体積に近づくように近似することを指します",
"Darbouxの定理":"積分可能な関数の任意の閉区間において、上積分と下積分が等しくなるという定理です",
"積分可能":"関数の上積分と下積分が等しくなることを指します",
"重積分":"多変数函数の積分のことで、二変数函数の場合は、x座標とy座標について別々に積分をすることによって計算されます。3変数の場合は、x、y、zについて積分をすることになります",
"重積分":"積分領域を分割し、それぞれの小さな領域について積分を求め、その総和を求めることによって計算されます。この総和をRiemann和と呼びます",
"重積分を求めるためには、":"積分領域を分割し、それぞれの小さな領域についてx、y、zの座標を求め、それらを用いて積分を求める必要があります",
"また、重積分は":"Darbouxの定理によって、積分可能な函数に限られます",
"重積分は、":"積分領域を分割し、それぞれの小さな領域について積分を求め、その総和を求めることによって計算されます。この総和をRiemann和と呼びます。",
"Riemann和は、":"積分を近似的に求める方法の一つで、関数の値を積分範囲内の矩形の面積に近似して求める方法です。Riemann和は、積分範囲を分割しそれぞれの分割された範囲の面積を求めることで算出されます",
"定義関数は、":"数学において、特定の関係や結果を表すために用いられる数学的な式のことです。たとえば、 y=f(x) は x の値を入力し、 y の値を出力する関数を表します。定義関数は、特定の範囲内で定義され、その範囲外では定義されていないことが一般的です",
"体積確定":" 3次元空間において、ある領域からなる立体が所定の体積を持つことを言います",
"Jordan集合":" 閉領域とそれに属する開領域からなる集合",
"区分的に滑らか":" 一部分が微分可能であり、他の部分が微分不可能であることを言います",
"ゼロ拡張":" 関数の中で値が0になる部分を拡大することを言います",
"積分可能":" 定義域から積分値を得ることができることを言います",
"中間値の定理":" 2つの積分の中間値についての不等式",
"重積分の平均値の定理":" 2つの変数の関数の積分の平均値についての不等式",
"集合の直径":" 集合中の2点間の最大距離",
"累次積分":" 一変数関数を多変数関数に拡張すること",
"縦線閉領域":" 一点からなる閉領域",
"Fubiniの定理":" 多変数関数の積分について、積分の順序を入れ替えることができることを示す定理",
"微分と積分の順序変換":" 微分と積分を入れ替えること",
"近似増大列":" 関数が増加すること",
"広義積分可能は、":"関数が広義積分可能であることを表します。広義積分は、通常の積分と異なり、非常に不規則な関数や、無限の部分積分を含む関数を積分することができます",
"非負値関数の広義積分は、":"非負値の関数の積分を指します。これは、非負値の関数についてのみ有効であり、負値の関数には適用できません",
"優関数定理は、":"広義積分の公式の一つで、非負値関数の積分と、その関数の上積分と下積分の中間値との等しさを示します",
"変数変換は、":"積分の公式を変換する方法の一つで、変数変換によって計算を容易にすることができます",
"広義積分の変数変換は、":"広義積分に対して変数変換を行うことを指します。これは、広義積分の場合には特に重要であるため、広義積分に特化した変数変換が必要になります",
"空間極座標は、":"3次元空間上の点を表す座標系の一つです。これは、点から原点への距離、その点が原点から見た極角、その点が原点から見た方位角の3つの値から構成されます",
"円柱座標":" 3次元空間上の点を、その点から原点への距離、その点と原点に対する2つの平面上の角度（高度角、方位角）で指定する座標系のこと",
"線形変換":" 入力ベクトルと出力ベクトルの関係が一次多項式の関数で表せる変換",
"各点収束":" 関数が各点で収束すること",
"極限関数":" 任意の変数が定数に近づくにつれて、関数の値が定数に近づく関数",
"一様数束":" 関数が点集上のすべての点で同じ上界を持つこと",
"一様収束極限":" 関数が点集上のすべての点で極限を持つこと",
"Diniの定理":" 上界が一様数束である非負整数値関数の各点収束極限は、一様収束極限である",
"広義一様収束":" 関数が点集上のすべての点で広義極限を持つこと",
"積分と極限の順序変換":" 積分と極限を順番を変えて計算すること",
"微分と極限の順序変換":" 微分と極限を順番を変えて計算すること",
"Cauchy列":" 収束する級数の列",
"関数項級数":" 関数を級数展開した形で表したもの",
"各点収束":" 関数が各点で収束すること"
      };
      
      var dictionary = document.getElementById("dictionary");
      for (var term in terms) {
        var p = document.createElement("p");
        var definition = document.createElement("span");
        definition.innerHTML = terms[term];
        definition.classList.add("definition");
        p.innerHTML = term;
        p.appendChild(definition);
        p.classList.add("term");
        dictionary.appendChild(p);
      }
      
      dictionary.addEventListener("click", function(event) {
        var target = event.target;
        if (target.classList.contains("term")) {
          var definition = target.querySelector(".definition");
          if(definition.classList.contains("show")){
            definition.classList.remove("show");
          }else{
            definition.classList.add("show");
          }
        }
      });
    </script>
  </body>
</html>
